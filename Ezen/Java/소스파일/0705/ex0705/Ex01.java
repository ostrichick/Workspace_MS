package studyJava.ex0705;

public class Ex01 {
	public static void main(String[] args) {
		
		//부호 연산자는 +또는-기호를 사용하여 음수 또는 양수를 표현할 수 있다.
		//대상은 리터럴 또는 변수 (boolean 과 char 타입 제외한 기본타입)
		System.out.println(-10);
		int a =-10;
		System.out.println(-a);
		
		//증감 연산자는 ++ 또는 -- 기호를 사용하며 1씩 증가 또는 1씩 감소하게 된다.
		a=0;
		//증감 연산자가 변수의 뒤에 붙어 있으면 후위 증가 또는 후위 감소라고 한다.
		//이때 연산은 실행문을 실행한 뒤에 이루어 진다.
		int b = a++;
		System.out.println(b);
		
		System.out.println(a); //a->1
		
		//증감 연산자가 변수 앞에 붙어있으면 전위증가 또는 전위감소라고 한다.
		//이때 연산은 증감연산자를 먼저 실행 한 후 실행문을 실행한다.
		b = --a;
		System.out.println(b);
		
		
		//산술 연산자
		//종류 -> +,-,/,*,% 
		//우선순위는 /,*,% 가 동일하게 높고 +,-가 동일하게 낮다.
		a = 2*(3+4); //우선순위에 따라 연산의 방향은 왼쪽에서 오른쪽으로 *,/,%부터 연산한다.
		//() 괄호를 사용하면 우선순위보다 먼저 연산식을 실행 할 수 있다.
		System.out.println(a);
		
		
		a = 10;
		double bb =2.0;
		
		//산술 연산에서 피연산자의 데이터 타입이 다른 경우 더 큰 데이터 타입으로 자동 형변환이 된다.
		double result = a+bb;
		
		// 정수 연산에서 값을 0으로 나누거나 나머지를 구하려 시도하는 경우  / by zero 해당 오류가 
		// 발생하며 시스템이 종료 된다.
		//int intResult  = 10%0;
		
		// 컴파일러는 연산식에서 데이터를 확인하지는 않기 때문에 0.0 으로 또는 0으로 나누려고할때
		// 컴파일 오류를 내지 않는다.
		//실수를 0.0으로 나누는 결과에 대해서는 오류를 내지 않는다.
		//개발 단계에서 값을 예측하여 따로 처리를 해야한다. (예외처리 X)
		result = 10.0/0.0;
		
		//실수에서 0.0으로 값을 나누는 경우 정확한 0 값을 가지지 않기 때문에
		//몫이 무한대가 발생하여 Infinity값을 출력하게 된다.
		System.out.println(result);
		
		//실수에서 0.0으로 값을 나눈 나머지를 구하는 경우 나머지가 정확하지 않으므로
		// NaN 값을 출력하게 된다.
		result =10.0%0.0;
		System.out.println(result);
		
		
		//문자열 연산자 (+)
		//문자열 연산자는 산술 연산의 덧셈과 기호가 동일하고 우선순위도 동일하기 때문에
		// 피연산자 둘장 하나라도 문자열이면 문자열 연산자가 된다.
		//이때 문자열은 자바의 참조타입 종류 중 하나다.
		// 데이터 타입은 String으로 표현한다.
		
		//자바에서 문자와 문자열은 다르다.
		//문자는 ''작은 따옴표로 표현한다.
		//char c = ''; 문자 타입에는 빈문자열을 담을 수 없다.(유니코드 없음)
		//문자열은 데이터 끝에 널 값을 담고 있어 문자열임을 데이터 상에 표현한다.
		// 빈문자를 표현할 때는 문자열 변수를 사용하여야만 한다.
		String str = "";
		a = 10;
		System.out.println(str+a); //str 의 빈문자열+ 정수 10 = 문자열10
		
		System.out.println(str+(a+a)); //1.10 2.20(o) 3.1010
		
		//비교연산자
		//두 피연산자의 값을 비교하여 논리타입의 결과를 도출함.
		//비교 연산에서 기준은 피연산자 1이된다.
		a = 10;
		int aa = 20;
		System.out.println(a>aa); //피연산자1이 피연산자2보다 큰지 비교
		
		aa=10;
		System.out.println(aa==a); //피연산자1이 피연산자2의 값과 같은지 비교
		
		aa=20;
		System.out.println(a!=aa); //피연산자1이 피연산자2의 값과 다른지 비교
		
		aa=10;
		bb=10.0;
		//비교연산도 피연산자 두개의 데이터 타입이 다른경우 자동형변환이 되나
		//실수같은 경우는 정확한 값을 가지지 않기 때문에 되도록 정수로 비교하는 것이 좋다.
		System.out.println(aa==bb);
		
		//비트 연산자는 정수 타입에서만 사용할 수 있다.
		//정수만 비트에 정확한 데이터를 담을 수 있기 때문이다.
		//1이 true 이고 0이 false라는 것을 기억하면 쉽게 풀 수 있다.
		a=5;
		b=7;
		System.out.println(a&b);
		System.out.println(a|b);
		
		//비트 논리부정은 1의 보수를 구하는 것과 같다.
		System.out.println(~a);
		
		// >>>,>>,<<
		
		b=5;
		//<< 연산자는 bit를 왼쪽으로 몇칸씩 이동시키며 이때 넘치는 bit는 손실 된다.
		//뒤로 새로 생기는 bit에는 0이 채워진다.
		System.out.println(b<<2);
		
		// >> : 오른쪽으로 bit를 이동하며 오른쪽으로 넘치는 비트는 손실된다.
		//      왼쪽으로 새로 생성되는 bit는 부호와 동일한 비트로 채워진다.
		System.out.println(b>>3);
		
		System.out.println(-b>>3);
		
		// >>> : 오른쪽으로 bit 이동하며 넘치는 비트는 손실되고 
		//       새로 생성된 비트는 무조건 0으로 채운다.
		//       새로 생성된 부호부를 무조건 0으로 채우기 때문에 결과는 무조건 양수
		
		System.out.println(-b>>>3);

		
		a += 3; // a=a+3;
		str += 3; // str = str+3; 피연산자 둥 하나가 문자열 이므로 문자열 연산.
		
		
		a =20;
		
		//if 문은 조건식을 비교하교 true인 경우에 실행된다.
		if(a>100) {
			System.out.println("a는 100보다 큽니다.");
		}else if(a>80){ //else if는 if 조건에 대한 거짓 조건을 세분화 한때 사용한다.
			//위에서 부터 조건이 거짓이 되어 비교하므로 전제조건이 생긴다.
			
			//a는 100보다는 작거나 같고 80보다는 크다
			System.out.println("a는 100보다는 작거나 같고 80보다는 크다.");
			
		}else {
			System.out.println("a는 80보다 작습니다.");
			
		}
		
		//switch case문
		// true/false가 아니라 정확한 값의 비교를 하여 실행문을 분기시키는 문법
		char c ='가';
		
		switch('가') {
		case '가': 
			System.out.println("c의 값은 가 입니다.");
			break; 
			//switch 문은 해당 케이스서 부터 아래로 전부 실행하므로 
			//멈추고자하는 케이스에서 break 문을 작성하여야 한다.
		case '각':
			System.out.println("c의 값은 나 입니다.");
			break;
		case '다':
			System.out.println("c의 값은 다 입니다.");
			break;
		default: //default 는 해당 케이스가 존재하지 않을 경우 맨마지막에 호출 되므로 break 필요x
			System.out.println("가,각,다에 해당하지 않습니다.");
		
		}
		
		
	}
}
